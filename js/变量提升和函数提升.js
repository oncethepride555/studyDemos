//-------------------------------------------同名【函数表达式】和【函数声明】
// 【函数表达式】【只是 var test58; 提升】
/* var test58 = function(n1,n2){
    return n1 + n2;
}
// 【函数声明】【整个函数提升】
function test58(n1,n2){
    return n1 - n2;
} */

// 预解析时，当变量和函数同名时，优先留下函数的值（不管谁前或后，函数优先级更高）
// console.log(test58(5,"8"));

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// 转化为以下代码
/* function test58(n1,n2){
    return n1 - n2;
}
var test58; // 上一句已经声明了test58为一个函数，这句的声明被省略
test58 = function(n1,n2){ // 这一句给test58重新赋值了，最后起作用的就是这句
    return n1 + n2;
}
console.log(test58(5,"8")); // 58 */

// ---------------------------------

/* var a = 2;
function a(){}; // 函数提升
console.log(a); // 2 */

// ----------------------------------------同名【变量】和【函数表达式】

// var f = "我是变量f";
// console.log(f); // undefined
/* var f = function(){
    return "我是变量表达式f";
}
// 在这里f还是个函数
// console.log(f());
var f = "我是变量f"; */
// 但是在这里f就成了变量而不是函数
// console.log(f);

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// 分析一下上面的同名变量和函数
/* var f;
var f;
f = function(){
    return "我是变量表达式f";
}
f = "我是变量f"; */
// 最后f是变量
// 结论：f最后是啥就是啥

// -----------------------------------------同名【变量】和【函数声明】

// console.log(f()); // 这里f是函数
/* var f = "我是变量f";
// console.log(f); // ★注意！这里输出的也是 我是变量f 因为函数提升了
function f(){
    return "我是函数声明f";
} */
// console.log(f); // 我是变量f

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// 分析上面代码
/* function f(){ // 函数提升
    return "我是函数声明f";
}
var f; // 变量提升 已经声明了f，此处声明省略
f = "我是变量f"; // 重新赋值 */
// console.log(f); // 我是变量f

// ----------------------------------------换一下【变量】和【函数声明】的顺序看看

/* console.log(f()); // 这里f是函数
function f(){
    return "我是函数声明f";
}
// console.log(f()); // 这里f是函数
var f = "我是变量f"; */
// console.log(f); // 这里f是变量

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// 上面的代码如下理解:
// var f;
// function f(){
//     return "我是函数声明f";
// }
// f = "我是变量f";

// -------------------------------------------------函数表达式存在提升吗?

/* console.log(fn); // 这里 fn 为 undefined 而没有报错 fn is not defined;说明提升了
var fn = function(){
    return "我是函数表达式fn";
} */
